---
title: "Learning about street names using R"
description: |
  A tale about street names in Budapest.
author:
  - name: Daniel Banki
    url: https://twitter.com/banki_daniel
base_url: https://danielbanki.com  
date: 02-09-2020
output:
  distill::distill_article:
    toc: true
    toc_depth: 3
    self_contained: false
    highlight: default
    highlight_downlit: true
creative_commons: CC BY
categories:
  - R
preview: preview.png  
---

# Project description

**What can we learn about a city from its street names?**

When I was growing up in Budapest (Hungary), I certainly didn't think much about this question. But as I started exploring the city and its history more consciously, I kept bumping into interesting and unusual street names.

Street names preserve valuable information about---among other things---a city's geographical features, its history, as well as its famous inhabitants. Who are the people who have streets named after them, and what did they do to deserve such a merit?

This question is quite broad, and many local historians all over the world have surely spent decades working on exactly such topics. My goal with this project is a lot less ambitious: I focus only on a single city (Budapest) and on the professions of people who had streets named after them. Capturing a single aspect of people's lives certainly wouldn't satisfy a historian, but I hope this project can show that one can learn something meaningful about street names by using some readily available datasets and running a few lines of R code.

**Overview of the project**

If we want to know the professions of people who had streets named after them, we can proceed in four steps. First, we get all the streets in Budapest. Second, we identify which streets were named after a person. Third, we look up each person's profession(s). Finally, we assign a final label to each person (if the person had multiple professions).

# Street names in Budapest

The Hungarian Postal Service (Hungary's major postal service provider) maintains a database of all [postcodes in the country](https://www.posta.hu/szolgaltatasok/iranyitoszam-kereso). Almost all places in the country (including some larger cities) are identified by a single postcode. This isn't the case in Budapest: postcodes there vary even within a district. Because postcodes are not unique, every street of the city must be listed in this database (with its corresponding postcode).

Before we import the data, let's load the necessary packages:

```{r}
library(tidyverse)
library(readxl)
library(conflicted)
library(RCurl)
library(httr)
library(WikidataR)
library(rvest)
library(forcats)

conflict_prefer("filter", "dplyr")
```

Next we import the data, remove some unnecessary columns, and remove duplicated street names. Note: there are duplicates in the database for two reasons. First, a street or its segments can have more than one postcode. Second, streets with the same name may exist in various districts.

```{r}


# import the relevant sheet from the excel file
bp_streets <- read_excel("bp_streets.xlsx", sheet = 3)

# get rid of some unnecessary columns
bp_streets <- bp_streets %>% select(IRSZ, UTCANÉV, UTÓTAG, KER)

# rename columns
colnames(bp_streets) <- c("postcode", "street_name", "street_type", "district")

# remove duplicates
bp_streets <- bp_streets %>% distinct(street_name, .keep_all = TRUE)
```

This leaves us with `r length(bp_streets$street_name)` unique street names.

# Identifying the relevant streets

How do we know which streets were named after people without checking the street names one by one? We rely on two simple rules that, applied simultaneously, allow us to identify most such streets. First, the street name must consist of at least two words. Second, it must contain a Hungarian first (or given) name. Although we capture a large portion of names using these two rules, we miss some names such as some foreigners' names and one-word names that only have a last name.

## Rule 1: number of words

One-word names are identified by a lack of whitespace; we discard them.

```{r}
bp_streets <- bp_streets %>%
  mutate(has_ws = str_detect(bp_streets$street_name, " ")) %>%
  filter(has_ws == TRUE)
```

In the next step, we split street names into three columns: each word goes into a separate column. I chose three columns because it's fairly common to have three-word street names in Budapest, but longer street names are relatively rare.

```{r}
bp_streets <- bp_streets %>%
  separate(street_name, into = c("first", "second", "third"), sep = " ", remove = FALSE)
```

There are `r length(bp_streets$street_name)` streets in Budapest that have at least two words.

## Rule 2: contains first name

In Hungary there is a list of first names that people can legally have. We use this feature to identify the relevant streets. That is, if any of the words from the street name matches a legally recognized first name, we conclude that the street was indeed named after a person. Why are we considering all three words (if they exist) from the street's name, and not just the second and the third? Both approaches would yield similar results, but it's not uncommon to have streets with a given name in the first column with the following logic: for example, John [given name] general [occupation or other identifier] street.

The list of legally available names is managed by the Research Institute for Linguistics of the Hungarian Academy of Sciences, and it is available as a `txt` file from their website. (There is a separate list for male and female names.) We use the `getURLContent` function from the `RCurl` package to get the pages' contents.

```{r}
# get male names
men_list <- RCurl::getURLContent("http://www.nytud.mta.hu/oszt/nyelvmuvelo/utonevek/osszesffi.txt")

men_list <- men_list %>%
  str_split(., "\n") %>%
  unlist() %>%
  as.data.frame()

# get string length, remove if not between 1 and 20
men_list <- men_list %>%
  mutate(s_cont = str_count(.)) %>%
  filter(s_cont %in% c(1:20))


# get female names
women_list <- getURLContent("http://www.nytud.mta.hu/oszt/nyelvmuvelo/utonevek/osszesnoi.txt")

women_list <- women_list %>%
  str_split(., "\n") %>%
  unlist() %>%
  as.data.frame()

women_list <- women_list %>%
  mutate(s_cont = str_count(.)) %>%
  filter(s_cont %in% c(1:20))
```

Now we combine the two lists:

```{r}
combined_names <- rbind(men_list, women_list) %>% select(-s_cont)

colnames(combined_names) <- "names"
```

We check if any of the words from the street name matches a first name.

```{r}
bp_streets_names <- bp_streets %>%
  filter_at(vars(first, second, third), any_vars(. %in% combined_names$names))
```

```{r include = FALSE}
# number of entries dropped
diff <- setdiff(bp_streets, bp_streets_names)
```

By filtering out streets with no matching first names, we eliminated `r length(diff$street_name)` streets.

At the same time, we introduced two types of errors. First, we didn't pick up certain relevant streets: mainly those named after foreigners and those with Hungarian given names that don't exist today. Second, we classified certain streets as named after a person when, in reality, their names refer to something else. The second source of error is probably less consequential---we can at least partially correct it when we look up people's professions.

# Matching names with professions

We identified `r length(bp_streets_names$street_name)` streets that were likely named after people. In this part, we look up each person's profession. First, we search for the person's name on Wikidata and we extract the person's Wikidata ID. Based on this ID we then get information about the person, including his or her profession.

## Wikidata search

I considered two options to find people's professions: scrape the data from individual Wikipedia pages or query Wikidata in a structured way. I opted for the second option---some people's professions won't be available this way, but the data we get are more consistent, and are also easier to handle.

Wikidata is a knowledge base that contains information in a structured format; Wikipedia relies on this information. For our purposes, two things are important: items and properties. The person we are interested in is called an item. It has a unique identifier and several properties. A property is, for example, the person's sex, date of birth, or profession.

We use the `WikidataR` package for all Wikidata-related queries.

First, let's do a Wikidata search with each person's name (using the `find_item` function). We set the limit to one result per search---otherwise many related findings would be included as well (e.g., the person's spouse). We assume that the first result is the person of interest.

```{r eval=FALSE}
data <- purrr::map(bp_streets_names$street_name, find_item, limit = 1)
```

```{r include = FALSE}
# write_rds(name_ids, paste0(path, "/name_ids.rds"))
data <- read_rds("name_ids.rds")
```

Not all searches return a result. We remove those that don't, then we extract the Wikidata IDs.

```{r}
# remove zero list elements
data <- Filter(length, data) %>% flatten()

# look up IDs
name_id <- purrr::map(data, "id") %>% unlist()
```

Although many lesser-known people have Wikidata pages, some don't. This most likely means that we undersample people who were relevant locally but not nationally. If these people's professions differ significantly from those of nationally relevant people, then our final result can be misleading.

We have `length(name_id)` unique IDs. Let's now get data for these people (using the `get_item` function).

```{r eval=FALSE}
name_info <- purrr::map(name_id, get_item) %>% flatten()
```

```{r include=FALSE}
# write_rds(name_info, paste0(path, "/name_info.rds"))
name_info <- read_rds("name_info.rds")
```

We now have a list that contains a large amount of information about each person. In the next step, we find and extract the relevant properties.

## Extracting people's professions

We define two functions to automate the extraction and formatting of properties.

```{r}
# get_elem: function to extract specific value
get_elem <- function(i) {
  out <- i[["mainsnak"]][["datavalue"]][["value"]][["id"]]

  out
}
# if one row returns an error, return NA instead of throwing an error message
get_elem_na <- possibly(get_elem, otherwise = NA)

# extract_property: extract properties into a vector
extract_property <- function(data, property) {

  # extract information about property
  out <- extract_claims(data, property) %>% flatten()

  out <- map(out, get_elem_na)

  # if more than one profession is listed, concatenate them
  out <- map(out, paste, collapse = ",") %>% unlist()

  out
}
```

We then extract the relevant properties: profession (P106), instance (P31), and 'different from' (P1889). Why do we need the last two properties?

Instance determines if the item is a human being. As we searched on Wikidata and extracted the ID of the first search result in each case, it is possible that instead of finding the right person we found a non-human item. The property 'different from' denotes the ID of an item that is different from another item, with which it is often confused. In other words, if two people have the same name, then this property would be non-empty. As there are people with common family and given names in our data, there will be instances in which we won't be able to uniquely identify the person.

```{r}
jobs <- extract_property(name_info, "P106")
inst <- extract_property(name_info, "P31")
multiple <- extract_property(name_info, "P1889")
```

We combine the vectors containing property values. Then we filter based on the three properties: we keep only those observations in which a profession is available, the item refers to a human, and there aren't multiple people with the same name.

```{r}
desc_df <- tibble(name_id, jobs, inst, multiple)

desc_df_valid <- desc_df %>%
  filter(jobs != "NA" & inst == "Q5" & multiple == "NA") %>%
  select(name_id, jobs)
```

There are `r length(desc_df_valid$name_id)` individuals whom we can use in our later analysis.

# Assigning profession labels

For every person we may have multiple professions; we only keep the first three. Going forward, I will refer to these professions as the first, second, and third profession, which simply reflects the order in which they appear in Wikidata.

```{r}
# separate occupations into 3 columns - only keep first 3, discard the rest
desc_df_valid <- desc_df_valid %>%
  separate(jobs, sep = ",", into = c("occ1", "occ2", "occ3"), remove = FALSE)
```

Because of the way Wikidata is structured, we don't have the labels (e.g., writer) for the professions yet, only their item IDs. We take some preparatory steps to get the vector of unique IDs.

```{r}
# get_label: extract labels for item
get_label <- function(i) {
  id <- i$id
  label <- i[["labels"]][["en"]][["value"]]
  out <- c(id, label)
  out
}

get_label_na <- purrr::possibly(get_label, otherwise = NA)

# get vector of jobs
jobs_c <- str_split(jobs, ",") %>% unlist()

# remove NAs (NA is character here)
jobs_c <- jobs_c[!jobs_c %in% c("NA")] %>% unique()
```

## Label lookup table

We then look up the label for each profession ID:

```{r eval=FALSE}
prof_list <- WikidataR::get_item(jobs_list)
```

```{r include = FALSE}
# write_rds(prof_list, paste0(path, "/prof_list.rds"))
prof_list <- read_rds("prof_list.rds")
```

The next step is to create a lookup table, with IDs in the first and labels in the second column. Then we add the labels to our data frame containing people's IDs.

```{r}
labelled_list <- purrr::map(prof_list, get_label_na)

labelled_df <- do.call(rbind, labelled_list)

colnames(labelled_df) <- c("id", "label")

labelled_df <- as_tibble(labelled_df)

desc_df_valid <- left_join(desc_df_valid, labelled_df, by = c("occ1" = "id")) %>%
  left_join(., labelled_df, by = c("occ2" = "id")) %>%
  left_join(., labelled_df, by = c("occ3" = "id"))
```

## Assigning the final label

For some people we have more than one profession label. How do we decide which one to use in our analysis?

Our goal is to determine the most common professions of those who had streets named after them. Ideally, we would like to cluster professions into professional groups, such as cultural, political figures, scientists, etc. However, I couldn't find a sensible mapping between individual professions and higher-level categories. Instead, we take advantage of the fact that some people have various listed professions. If we can select the most common profession from the person's professions, we have gone some way toward a smaller number of final categories (and with more people in each). For example, one of the people in our list had the following professions: university teacher, engineer, geodesist. The most common category based on the first professions is engineer; this person would then be classified as an engineer. Intuitively, a person is likely to have related labels; instead of assigning a rare profession (geodesist) to a higher-category (scientist), we assign it to a common element of that category (engineer).

```{r}
# sort professions by frequency; largest first
rank_df <- as.data.frame(sort(table(desc_df_valid$label.x), decreasing = TRUE))

colnames(rank_df) <- c("label", "freq")

# convert three columns into a list
occ_list <- desc_df_valid %>%
  select(label, label.x, label.y) %>%
  asplit(., 1)

# get_min_rank: get most common label from each row
get_min_rank <- function(x) {
  x <- as.character(rank_df[min(match(x, rank_df$label, nomatch = length(rank_df$label) + 1)), 1])
  x
}

desc_df_valid$label_final <- purrr::map(occ_list, get_min_rank) %>% unlist()
```

To check if considering potentially three labels for each individual did make a difference, we calculate the number of times either the second or the third label was assigned as a final label.

```{r}
length(which(desc_df_valid$label.x != desc_df_valid$label_final))
```

Also, we check if (and how many) profession labels we managed to eliminate compared to collecting only a single label for every person.

```{r}
nlevels(as.factor(desc_df_valid$label.x)) - nlevels(as.factor(desc_df_valid$label_final))
```

It seems that the final labels are indeed more homogeneous than the first profession labels.

Now that we have the frequency of professions, let's visualize this information. First, we prepare the data and lump infrequent categories into the category "Other". A category is infrequent if there are fewer than 5 people with that profession.

```{r}
prof_freq <- as.data.frame(sort(table(desc_df_valid$label_final), decreasing = TRUE))

colnames(prof_freq) <- c("label", "freq")

# merge observations that have fewer than 5 entries into category "Other"
prof_freq_cats <- as.data.frame(sort(table(fct_lump_min(desc_df_valid$label_final, min = 5)), decreasing = TRUE))

colnames(prof_freq_cats) <- c("label", "freq")
```

## Visualizing the results & conclusion

We use `ggplot` to display the data visually:

```{r}
ggplot(prof_freq_cats, aes(label, freq)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = freq), vjust = -1) +
  labs(title = "Most frequent professions", x = "", y = "Count") +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5), axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) +
  ylim(0, max(prof_freq_cats$freq) + 50)
```

The results are in line with what can be expected: political figures (politician, soldier, military officer, military personnel), cultural figures (writer, poet, painter, sculptor), scientists (physicist, engineer, mathematician, historian) are the ones who have had streets named after them in Budapest. It would also be interesting to look at the era in which these people lived, their connections with Budapest, or if the distribution of professions was different at some point (e.g., following regime changes, which usually meant renaming some streets).

Although the results look reasonable, it's worth highlighting some aspects of this process once again that could introduce some (or even significant) bias. First, we may have left out a large number of people whose given names are not common, not Hungarian, or are formatted differently than common names. Second, we couldn't find information about all people, and where we did find information, it may have been about another person. Third, we may have chosen the wrong label for some people: for example, the person is famous for being a poet, yet we categorized her as a politician, because politician (the more common label) was also one of her labels.
